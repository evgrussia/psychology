---
alwaysApply: true
---
# Project Architecture Rules

## General Principles

All tasks related to application architecture design and implementation must follow the principles of **Clean Architecture** and **Domain-Driven Design (DDD)**.

## Clean Architecture

### Layer Structure

1. **Domain Layer**
   - Contains business logic and domain rules
   - Does not depend on external frameworks, libraries, or infrastructure (except standard language libraries)
   - Includes:
     - Entities
     - Value Objects
     - Domain Services
     - Domain Events
     - Repository Interfaces

2. **Application Layer**
   - Contains use cases (application scenarios)
   - Coordinates business logic execution
   - Depends only on Domain Layer
   - Includes:
     - Use Cases / Application Services
     - DTOs (Data Transfer Objects)
     - Application Events
     - Interfaces for external services

3. **Infrastructure Layer**
   - Implements technical details
   - Depends on Domain and Application layers
   - Includes:
     - Repository implementations
     - External API clients
     - Database
     - Frameworks and libraries
     - File system
     - Caching

4. **Presentation Layer**
   - UI/API controllers
   - Depends on Application Layer
   - Does not contain business logic
   - Only input validation and response formatting

### Dependency Rules

- **Dependencies point inward**: outer layers depend on inner layers
- **Domain Layer has no dependencies** (except standard language libraries)
- **Dependency Inversion**: use interfaces for abstractions
- **Do not mix layers**: each layer must be clearly separated

## Domain-Driven Design (DDD)

### Core Concepts

1. **Bounded Context**
   - Clearly define domain model boundaries
   - Each context has its own model and terminology
   - Avoid mixing contexts

2. **Aggregates**
   - Group related entities into aggregates
   - Aggregate has a root entity (Aggregate Root)
   - All changes go through Aggregate Root
   - Aggregates ensure data consistency

3. **Entities**
   - Objects with unique identity
   - Have a lifecycle
   - Can change over time

4. **Value Objects**
   - Defined only by their attributes
   - Immutable
   - Do not have an identifier

5. **Domain Services**
   - Contain business logic that does not belong to a specific entity
   - Stateless operations
   - Work with domain objects

6. **Repositories**
   - Abstraction for data access
   - Interfaces in Domain Layer
   - Implementations in Infrastructure Layer

7. **Domain Events**
   - Events occurring in the domain
   - Used for loose coupling between contexts
   - Published from domain objects

### Strategic Design

- Define **Ubiquitous Language** for each context
- Identify **Core Domain** and prioritize it
- Use **Context Mapping** to connect contexts

## Practical Implementation Rules

### When creating new functionality:

1. **Start with Domain Layer**
   - Define entities and value objects
   - Describe business rules
   - Create repository and service interfaces

2. **Then Application Layer**
   - Implement use cases
   - Use only interfaces from Domain Layer

3. **Then Infrastructure Layer**
   - Implement repositories
   - Connect external services

4. **Finally Presentation Layer**
   - Create controllers/components
   - Configure routing

### When refactoring:

- Do not move business logic to controllers or infrastructure layers
- Maintain Domain Layer independence
- Use dependency injection for dependency inversion

### When working with data:

- Use DTOs to transfer data between layers
- Do not use domain entities directly in API responses
- Mapping between layers must be explicit

### Testing:

- Domain Layer should be easily testable without infrastructure mocks
- Use Cases are tested with repository mocks
- Infrastructure Layer is tested with integration tests

## Forbidden Practices

- ❌ Placing business logic in controllers
- ❌ Direct dependencies on frameworks in domain layer
- ❌ Using ORM entities as domain entities
- ❌ Mixing layers in one module/package
- ❌ Violating dependency rules between layers
- ❌ Ignoring aggregate boundaries

## Recommended Practices

- ✅ Clear separation of responsibilities between layers
- ✅ Using interfaces for abstractions
- ✅ Immutability of value objects
- ✅ Encapsulating business rules in domain objects
- ✅ Using domain events for asynchronous communication
- ✅ Documenting bounded contexts and their relationships