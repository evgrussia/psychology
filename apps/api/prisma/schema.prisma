generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String                     @id @default(uuid()) @db.Uuid
  email             String?                    @unique
  phone             String?                    @unique
  telegram_user_id  String?                    @unique
  telegram_username String?
  display_name      String?
  status            UserStatus                 @default(active)
  created_at        DateTime                   @default(now())
  updated_at        DateTime                   @updatedAt
  deleted_at        DateTime?
  password_hash     String?
  ugc_questions     AnonymousQuestion[]
  appointments      Appointment[]
  audit_logs        AuditLogEntry[]
  consents          Consent[]
  authored_content  ContentItem[]
  content_revisions ContentRevision[]
  export_requests   DataExportRequest[]
  diary_entries     DiaryEntry[]
  interactive_runs  InteractiveRun[]
  leads             LeadIdentity[]
  uploaded_media    MediaAsset[]
  template_updates  MessageTemplateVersion[]
  ugc_answers       QuestionAnswer[]
  review_consents   ReviewPublicationConsent[]
  ugc_reviews       Review[]
  sessions          Session[]
  ugc_moderations   UgcModerationAction[]
  roles             UserRole[]
  waitlist_requests WaitlistRequest[]
  google_calendar_integrations GoogleCalendarIntegration[]

  @@map("users")
}

model Role {
  code          String        @id
  scope         RoleScope
  admin_invites AdminInvite[]
  user_roles    UserRole[]

  @@map("roles")
}

model UserRole {
  user_id    String   @db.Uuid
  role_code  String
  granted_at DateTime @default(now())
  role       Role     @relation(fields: [role_code], references: [code])
  user       User     @relation(fields: [user_id], references: [id])

  @@id([user_id, role_code])
  @@map("user_roles")
}

model Consent {
  id           String      @id @default(uuid()) @db.Uuid
  user_id      String      @db.Uuid
  consent_type ConsentType
  granted      Boolean     @default(true)
  version      String
  source       String
  granted_at   DateTime    @default(now())
  revoked_at   DateTime?
  user         User        @relation(fields: [user_id], references: [id])

  @@map("consents")
}

model Session {
  id         String    @id @default(uuid()) @db.Uuid
  user_id    String    @db.Uuid
  user_agent String?
  ip_address String?
  expires_at DateTime
  created_at DateTime  @default(now())
  revoked_at DateTime?
  user       User      @relation(fields: [user_id], references: [id])

  @@map("sessions")
}

model AdminInvite {
  id         String    @id @default(uuid()) @db.Uuid
  email      String    @unique
  role_code  String
  token      String    @unique
  expires_at DateTime
  created_at DateTime  @default(now())
  used_at    DateTime?
  role       Role      @relation(fields: [role_code], references: [code])

  @@map("admin_invites")
}

model ContentItem {
  id              String             @id @default(uuid()) @db.Uuid
  content_type    ContentType
  slug            String
  title           String
  excerpt         String?
  body_markdown   String
  status          ContentStatus      @default(draft)
  published_at    DateTime?
  author_user_id  String             @db.Uuid
  time_to_benefit TimeToBenefit?
  format          ContentFormat?
  support_level   SupportLevel?
  created_at      DateTime           @default(now())
  updated_at      DateTime           @updatedAt
  canonical_url   String?
  seo_description String?
  seo_keywords    String?
  seo_title       String?
  tags            ContentItemTag[]
  topics          ContentItemTopic[]
  author          User               @relation(fields: [author_user_id], references: [id])
  media           ContentMedia[]
  revisions       ContentRevision[]
  in_collections  CuratedItem[]
  glossary_links  GlossaryTermLink[]

  @@unique([content_type, slug])
  @@index([status, content_type, slug])
  @@map("content_items")
}

model ContentRevision {
  id                 String      @id @default(uuid()) @db.Uuid
  content_item_id    String      @db.Uuid
  body_markdown      String
  title              String
  excerpt            String?
  meta               Json?
  changed_by_user_id String      @db.Uuid
  created_at         DateTime    @default(now())
  changed_by         User        @relation(fields: [changed_by_user_id], references: [id])
  content_item       ContentItem @relation(fields: [content_item_id], references: [id])

  @@map("content_revisions")
}

model Topic {
  code          String                  @id
  title         String
  is_active     Boolean                 @default(true)
  content_items ContentItemTopic[]
  interactives  InteractiveDefinition[]
  leads         Lead[]
  services      Service[]

  @@map("topics")
}

model Tag {
  id            String           @id @default(uuid()) @db.Uuid
  slug          String           @unique
  title         String
  content_items ContentItemTag[]

  @@map("tags")
}

model ContentItemTopic {
  content_item_id String      @db.Uuid
  topic_code      String
  content_item    ContentItem @relation(fields: [content_item_id], references: [id])
  topic           Topic       @relation(fields: [topic_code], references: [code])

  @@id([content_item_id, topic_code])
  @@map("content_item_topics")
}

model ContentItemTag {
  content_item_id String      @db.Uuid
  tag_id          String      @db.Uuid
  content_item    ContentItem @relation(fields: [content_item_id], references: [id])
  tag             Tag         @relation(fields: [tag_id], references: [id])

  @@id([content_item_id, tag_id])
  @@map("content_item_tags")
}

model MediaAsset {
  id                  String               @id @default(uuid()) @db.Uuid
  storage_provider    MediaStorageProvider @default(local_fs)
  object_key          String               @unique
  public_url          String
  media_type          MediaType
  mime_type           String
  size_bytes          BigInt
  title               String?
  alt_text            String?
  uploaded_by_user_id String               @db.Uuid
  created_at          DateTime             @default(now())
  usages              ContentMedia[]
  appointment_materials AppointmentMaterial[]
  uploaded_by         User                 @relation(fields: [uploaded_by_user_id], references: [id])

  @@map("media_assets")
}

model ContentMedia {
  content_item_id String      @db.Uuid
  media_asset_id  String      @db.Uuid
  usage           MediaUsage
  content_item    ContentItem @relation(fields: [content_item_id], references: [id])
  media_asset     MediaAsset  @relation(fields: [media_asset_id], references: [id])

  @@id([content_item_id, media_asset_id, usage])
  @@map("content_media")
}

model CuratedCollection {
  id              String         @id @default(uuid()) @db.Uuid
  slug            String         @unique
  title           String
  collection_type CollectionType
  status          ContentStatus  @default(draft)
  topic_code      String?
  published_at    DateTime?
  items           CuratedItem[]

  @@map("curated_collections")
}

model CuratedItem {
  id                        String                 @id @default(uuid()) @db.Uuid
  collection_id             String                 @db.Uuid
  item_type                 CuratedItemType
  content_item_id           String?                @db.Uuid
  interactive_definition_id String?                @db.Uuid
  position                  Int
  note                      String?
  collection                CuratedCollection      @relation(fields: [collection_id], references: [id])
  content_item              ContentItem?           @relation(fields: [content_item_id], references: [id])
  interactive_definition    InteractiveDefinition? @relation(fields: [interactive_definition_id], references: [id])

  @@map("curated_items")
}

model GlossaryTerm {
  id               String                @id @default(uuid()) @db.Uuid
  slug             String                @unique
  title            String
  category         GlossaryTermCategory
  short_definition String
  body_markdown    String
  status           ContentStatus         @default(draft)
  published_at     DateTime?
  meta_description String?
  keywords         String?
  links            GlossaryTermLink[]
  synonyms         GlossaryTermSynonym[]

  @@map("glossary_terms")
}

model GlossaryTermSynonym {
  id      String       @id @default(uuid()) @db.Uuid
  term_id String       @db.Uuid
  synonym String
  term    GlossaryTerm @relation(fields: [term_id], references: [id])

  @@map("glossary_term_synonyms")
}

model GlossaryTermLink {
  id              String       @id @default(uuid()) @db.Uuid
  term_id         String       @db.Uuid
  content_item_id String       @db.Uuid
  link_type       String
  content_item    ContentItem  @relation(fields: [content_item_id], references: [id])
  term            GlossaryTerm @relation(fields: [term_id], references: [id])

  @@map("glossary_term_links")
}

model InteractiveDefinition {
  id               String            @id @default(uuid()) @db.Uuid
  interactive_type InteractiveType
  slug             String
  title            String
  topic_code       String?
  status           InteractiveStatus @default(draft)
  published_at     DateTime?
  definition_json  Json?
  curated_items    CuratedItem[]
  topic            Topic?            @relation(fields: [topic_code], references: [code])
  runs             InteractiveRun[]

  @@unique([interactive_type, slug])
  @@map("interactive_definitions")
}

model InteractiveRun {
  id                        String                @id @default(uuid()) @db.Uuid
  interactive_definition_id String                @db.Uuid
  user_id                   String?               @db.Uuid
  anonymous_id              String?
  started_at                DateTime              @default(now())
  completed_at              DateTime?
  result_level              ResultLevel?
  result_profile            String?
  duration_ms               Int?
  deep_link_id              String?
  crisis_trigger_type       String?
  crisis_triggered          Boolean               @default(false)
  deep_link                 DeepLink?             @relation(fields: [deep_link_id], references: [deep_link_id])
  definition                InteractiveDefinition @relation(fields: [interactive_definition_id], references: [id])
  user                      User?                 @relation(fields: [user_id], references: [id])

  @@map("interactive_runs")
}

model Service {
  id                   String             @id @default(uuid()) @db.Uuid
  slug                 String             @unique
  title                String
  description_markdown String
  format               ServiceFormat
  offline_address      String?
  duration_minutes     Int
  price_amount         Int
  deposit_amount       Int?
  cancel_free_hours    Int?
  cancel_partial_hours Int?
  reschedule_min_hours Int?
  reschedule_max_count Int?
  status               ServiceStatus      @default(draft)
  topic_code           String?
  created_at           DateTime           @default(now())
  updated_at           DateTime           @updatedAt
  appointments         Appointment[]
  slots                AvailabilitySlot[]
  waitlist_requests    WaitlistRequest[]
  topic                Topic?             @relation(fields: [topic_code], references: [code])

  @@map("services")
}

model AvailabilitySlot {
  id                String       @id @default(uuid()) @db.Uuid
  service_id        String?      @db.Uuid
  start_at_utc      DateTime
  end_at_utc        DateTime
  status            SlotStatus   @default(available)
  source            SlotSource   @default(product)
  external_event_id String?
  created_at        DateTime     @default(now())
  appointment       Appointment?
  service           Service?     @relation(fields: [service_id], references: [id])

  @@index([start_at_utc, end_at_utc, status])
  @@index([source])
  @@unique([start_at_utc, end_at_utc, source, service_id])
  @@map("availability_slots")
}

model Appointment {
  id                         String            @id @default(uuid()) @db.Uuid
  service_id                 String            @db.Uuid
  client_user_id             String?           @db.Uuid
  lead_id                    String?           @db.Uuid
  client_request_id          String?           @unique
  start_at_utc               DateTime
  end_at_utc                 DateTime
  timezone                   String
  format                     ServiceFormat
  status                     AppointmentStatus @default(pending_payment)
  meeting_url                String?
  location_text              String?
  slot_id                    String?           @unique @db.Uuid
  external_calendar_event_id String?
  created_at                 DateTime          @default(now())
  updated_at                 DateTime          @updatedAt
  client                     User?             @relation(fields: [client_user_id], references: [id])
  lead                       Lead?             @relation(fields: [lead_id], references: [id])
  service                    Service           @relation(fields: [service_id], references: [id])
  slot                       AvailabilitySlot? @relation(fields: [slot_id], references: [id])
  intake_form                IntakeForm?
  payments                   Payment[]
  materials                  AppointmentMaterial[]

  @@index([start_at_utc, end_at_utc, status])
  @@index([start_at_utc])
  @@index([status])
  @@map("appointments")
}

model AppointmentMaterial {
  id             String                  @id @default(uuid()) @db.Uuid
  appointment_id String                  @db.Uuid
  material_type  AppointmentMaterialType
  title          String
  description    String?
  link_url       String?
  media_asset_id String?                 @db.Uuid
  created_at     DateTime                @default(now())
  updated_at     DateTime                @updatedAt
  appointment    Appointment             @relation(fields: [appointment_id], references: [id])
  media_asset    MediaAsset?             @relation(fields: [media_asset_id], references: [id])

  @@index([appointment_id])
  @@map("appointment_materials")
}

model Payment {
  id                  String          @id @default(uuid()) @db.Uuid
  appointment_id      String          @db.Uuid
  provider            PaymentProvider @default(yookassa)
  provider_payment_id String          @unique
  amount              Int
  currency            String          @default("RUB")
  status              PaymentStatus   @default(pending)
  failure_category    String?
  idempotency_key     String?         @unique
  created_at          DateTime        @default(now())
  confirmed_at        DateTime?
  appointment         Appointment     @relation(fields: [appointment_id], references: [id])

  @@index([provider, provider_payment_id])
  @@map("payments")
}

model PaymentWebhookEvent {
  id                String          @id @default(uuid()) @db.Uuid
  provider          PaymentProvider
  provider_event_id String          @unique
  received_at       DateTime        @default(now())
  processed_at      DateTime?

  @@index([provider, received_at])
  @@map("payment_webhook_events")
}

model IntakeForm {
  id                String      @id @default(uuid()) @db.Uuid
  appointment_id    String      @unique @db.Uuid
  status            String      @default("draft")
  payload_encrypted String
  submitted_at      DateTime?
  appointment       Appointment @relation(fields: [appointment_id], references: [id])

  @@map("intake_forms")
}

model WaitlistRequest {
  id                      String         @id @default(uuid()) @db.Uuid
  user_id                 String?        @db.Uuid
  service_id              String         @db.Uuid
  preferred_contact       String
  contact_value_encrypted String
  preferred_time_window   String?
  status                  WaitlistStatus @default(new)
  created_at              DateTime       @default(now())
  service                 Service        @relation(fields: [service_id], references: [id])
  user                    User?          @relation(fields: [user_id], references: [id])

  @@map("waitlist_requests")
}

model DiaryEntry {
  id                String    @id @default(uuid()) @db.Uuid
  user_id           String    @db.Uuid
  diary_type        DiaryType
  entry_date        DateTime  @db.Date
  payload_encrypted String
  has_text          Boolean   @default(false)
  created_at        DateTime  @default(now())
  deleted_at        DateTime?
  user              User      @relation(fields: [user_id], references: [id])

  @@map("diary_entries")
}

model DataExportRequest {
  id           String       @id @default(uuid()) @db.Uuid
  user_id      String       @db.Uuid
  export_type  ExportType
  status       ExportStatus @default(requested)
  file_url     String?
  created_at   DateTime     @default(now())
  completed_at DateTime?
  user         User         @relation(fields: [user_id], references: [id])

  @@map("data_export_requests")
}

model DeepLink {
  deep_link_id     String              @id
  flow             String
  tg_target        String              @default("bot")
  topic_code       String?
  entity_ref       String?
  source_page      String?
  anonymous_id     String?
  lead_id          String?             @db.Uuid
  created_at       DateTime            @default(now())
  expires_at       DateTime
  lead             Lead?               @relation(fields: [lead_id], references: [id])
  interactive_runs InteractiveRun[]
  timeline_events  LeadTimelineEvent[]
  telegram_sessions TelegramSession[]

  @@index([created_at])
  @@map("deep_links")
}

model TelegramUser {
  telegram_user_id String           @id
  username         String?
  first_name       String?
  last_name        String?
  language_code    String?
  is_bot           Boolean          @default(false)
  created_at       DateTime         @default(now())
  updated_at       DateTime         @updatedAt
  last_seen_at     DateTime?
  sessions         TelegramSession[]

  @@map("telegram_users")
}

model TelegramSession {
  id                   String        @id @default(uuid()) @db.Uuid
  telegram_user_id     String
  state                String
  flow                 String?
  deep_link_id         String?
  topic_code           String?
  frequency            String?
  concierge_payload    Json?
  is_active            Boolean       @default(true)
  started_at           DateTime      @default(now())
  updated_at           DateTime      @updatedAt
  stopped_at           DateTime?
  last_interaction_at  DateTime?
  telegram_user        TelegramUser  @relation(fields: [telegram_user_id], references: [telegram_user_id])
  deep_link            DeepLink?     @relation(fields: [deep_link_id], references: [deep_link_id])

  @@index([telegram_user_id, is_active])
  @@map("telegram_sessions")
}

model Lead {
  id              String              @id @default(uuid()) @db.Uuid
  status          LeadStatus          @default(new)
  source          LeadSource
  topic_code      String?
  utm             Json?
  created_at      DateTime            @default(now())
  updated_at      DateTime            @updatedAt
  appointments    Appointment[]
  deep_links      DeepLink[]
  identities      LeadIdentity[]
  timeline_events LeadTimelineEvent[]
  topic           Topic?              @relation(fields: [topic_code], references: [code])

  @@map("leads")
}

model LeadIdentity {
  id               String   @id @default(uuid()) @db.Uuid
  lead_id          String   @db.Uuid
  user_id          String?  @db.Uuid
  anonymous_id     String?
  email_encrypted  String?
  phone_encrypted  String?
  telegram_user_id String?
  is_primary       Boolean  @default(false)
  created_at       DateTime @default(now())
  lead             Lead     @relation(fields: [lead_id], references: [id])
  user             User?    @relation(fields: [user_id], references: [id])

  @@map("lead_identities")
}

model LeadTimelineEvent {
  id           String    @id @default(uuid()) @db.Uuid
  lead_id      String    @db.Uuid
  event_name   String
  source       String
  occurred_at  DateTime  @default(now())
  deep_link_id String?
  properties   Json
  deep_link    DeepLink? @relation(fields: [deep_link_id], references: [deep_link_id])
  lead         Lead      @relation(fields: [lead_id], references: [id])

  @@index([lead_id, occurred_at])
  @@map("lead_timeline_events")
}

model AnonymousQuestion {
  id                      String                @id @default(uuid()) @db.Uuid
  user_id                 String?               @db.Uuid
  status                  UGCStatus             @default(pending)
  trigger_flags           Json?
  question_text_encrypted String
  contact_value_encrypted String?
  publish_allowed         Boolean               @default(false)
  submitted_at            DateTime              @default(now())
  answered_at             DateTime?
  user                    User?                 @relation(fields: [user_id], references: [id])
  answers                 QuestionAnswer[]
  moderations             UgcModerationAction[]

  @@index([status, submitted_at])
  @@map("anonymous_questions")
}

model QuestionAnswer {
  id                    String            @id @default(uuid()) @db.Uuid
  question_id           String            @db.Uuid
  answered_by_user_id   String            @db.Uuid
  answer_text_encrypted String
  published_at          DateTime          @default(now())
  answered_by           User              @relation(fields: [answered_by_user_id], references: [id])
  question              AnonymousQuestion @relation(fields: [question_id], references: [id])

  @@map("question_answers")
}

model UgcModerationAction {
  id                String                    @id @default(uuid()) @db.Uuid
  ugc_type          String
  ugc_id            String                    @db.Uuid
  moderator_user_id String                    @db.Uuid
  action            ModerationActionType
  reason_category   ModerationReasonCategory?
  created_at        DateTime                  @default(now())
  moderator         User                      @relation(fields: [moderator_user_id], references: [id])
  question          AnonymousQuestion         @relation(fields: [ugc_id], references: [id])

  @@map("ugc_moderation_actions")
}

model Review {
  id                    String                     @id @default(uuid()) @db.Uuid
  user_id               String?                    @db.Uuid
  status                String                     @default("draft")
  review_text_encrypted String
  anonymity_level       String                     @default("full")
  submitted_at          DateTime                   @default(now())
  published_at          DateTime?
  consents              ReviewPublicationConsent[]
  user                  User?                      @relation(fields: [user_id], references: [id])

  @@map("reviews")
}

model ReviewPublicationConsent {
  id         String    @id @default(uuid()) @db.Uuid
  review_id  String    @db.Uuid
  user_id    String?   @db.Uuid
  granted    Boolean   @default(false)
  version    String
  granted_at DateTime  @default(now())
  revoked_at DateTime?
  review     Review    @relation(fields: [review_id], references: [id])
  user       User?     @relation(fields: [user_id], references: [id])

  @@map("review_publication_consents")
}

model GoogleCalendarIntegration {
  id                       String                          @id @default(uuid()) @db.Uuid
  status                   GoogleCalendarIntegrationStatus @default(pending)
  calendar_id              String?
  timezone                 String?
  encrypted_access_token   String?
  encrypted_refresh_token  String?
  token_expires_at         DateTime?
  scopes                   String[]                        @default([])
  oauth_state              String?
  oauth_state_expires_at   DateTime?
  connected_by_user_id     String?                         @db.Uuid
  connected_at             DateTime?
  last_sync_at             DateTime?
  last_sync_error          String?
  last_sync_range_start_at DateTime?
  last_sync_range_end_at   DateTime?
  created_at               DateTime                        @default(now())
  updated_at               DateTime                        @updatedAt
  connected_by             User?                           @relation(fields: [connected_by_user_id], references: [id])

  @@index([status])
  @@map("integrations_google_calendar")
}

model AuditLogEntry {
  id            String   @id @default(uuid()) @db.Uuid
  actor_user_id String?  @db.Uuid
  actor_role    String?
  action        String
  entity_type   String
  entity_id     String?  @db.Uuid
  old_value     Json?
  new_value     Json?
  ip_address    String?
  user_agent    String?
  created_at    DateTime @default(now())
  actor         User?    @relation(fields: [actor_user_id], references: [id])

  @@map("audit_log_entries")
}

model MessageTemplate {
  id         String                   @id @default(uuid()) @db.Uuid
  channel    MessageChannel
  category   MessageCategory
  name       String
  status     String                   @default("draft")
  created_at DateTime                 @default(now())
  versions   MessageTemplateVersion[]

  @@map("message_templates")
}

model MessageTemplateVersion {
  id                 String          @id @default(uuid()) @db.Uuid
  template_id        String          @db.Uuid
  version            Int
  subject            String?
  body_markdown      String
  updated_by_user_id String          @db.Uuid
  created_at         DateTime        @default(now())
  template           MessageTemplate @relation(fields: [template_id], references: [id])
  updated_by         User            @relation(fields: [updated_by_user_id], references: [id])

  @@map("message_template_versions")
}

enum UserStatus {
  active
  blocked
  deleted
}

enum RoleScope {
  admin
  product
}

enum ConsentType {
  personal_data
  communications
  telegram
  review_publication
}

enum ContentType {
  article
  note
  resource
  landing
  page
}

enum ContentStatus {
  draft
  review
  published
  archived
}

enum ContentFormat {
  article
  note
  resource
  audio
  checklist
}

enum SupportLevel {
  self_help
  micro_support
  consultation
}

enum TimeToBenefit {
  min_1_3
  min_7_10
  min_20_30
  series
}

enum MediaStorageProvider {
  local_fs
}

enum MediaType {
  image
  audio
  pdf
}

enum MediaUsage {
  cover
  inline
  attachment
  audio
}

enum CollectionType {
  problem
  format
  goal
  context
}

enum CuratedItemType {
  content
  interactive
}

enum GlossaryTermCategory {
  approach
  state
  concept
}

enum InteractiveType {
  quiz
  navigator
  thermometer
  boundaries
  prep
  ritual
}

enum InteractiveStatus {
  draft
  published
  archived
}

enum RunStatus {
  in_progress
  completed
  abandoned
}

enum ResultLevel {
  low
  moderate
  high
}

enum ServiceFormat {
  online
  offline
  hybrid
}

enum ServiceStatus {
  draft
  published
  archived
}

enum SlotStatus {
  available
  reserved
  blocked
}

enum SlotSource {
  product
  google_calendar
}

enum AppointmentStatus {
  pending_payment
  paid
  confirmed
  canceled
  rescheduled
  completed
}

enum AppointmentMaterialType {
  link
  file
}

enum PaymentProvider {
  yookassa
}

enum PaymentStatus {
  pending
  succeeded
  canceled
  failed
}

enum WaitlistStatus {
  new
  contacted
  closed
}

enum DiaryType {
  emotions
  abc
  sleep_energy
  gratitude
}

enum ExportType {
  user_data
  diary_pdf
}

enum ExportStatus {
  requested
  processing
  ready
  failed
}

enum LeadStatus {
  new
  engaged
  booking_started
  booked_confirmed
  paid
  completed_session
  follow_up_needed
  inactive
}

enum LeadSource {
  quiz
  telegram
  waitlist
  question
  booking
}

enum UGCStatus {
  pending
  flagged
  approved
  answered
  rejected
}

enum UGCTriggerFlag {
  crisis
  pii
  medical
  spam
}

enum ModerationActionType {
  approve
  reject
  flag
  mask_pii
  publish
  unpublish
  escalate
}

enum ModerationReasonCategory {
  crisis
  medical
  out_of_scope
  therapy_request
  spam
  pii
  other
}

enum GoogleCalendarIntegrationStatus {
  disconnected
  pending
  connected
  error
}

enum MessageChannel {
  email
  telegram
}

enum MessageCategory {
  booking
  waitlist
  event
  moderation
}

enum AdminAction {
  admin_price_changed
  admin_data_exported
  admin_content_published
}
